# [LeetCode41.缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)
## 题目描述
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

字节变形：找出其中没有出现的最小的大于`K`的整数。
### 示例一
```
输入: [1,2,0]
输出: 3
```
### 示例二
```
输入: [3,4,-1,1]
输出: 2
```
### 示例三
```
输入: [7,8,9,11,12]
输出: 1
```
### 提示
你的算法的时间复杂度应为$O(n)$，并且只能使用常数级别的额外空间。
## 题解
### 解法一
哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在 $O(1)$ 的时间查找该元素是否在哈希表中。因此，我们可以考虑将给定的数组设计成哈希表的「替代产品」。

实际上，对于一个长度为 `N` 的数组，其中没有出现的最小正整数只能在 `[1,N+1]` 中。这是因为如果 `[1,N]` 都出现了，那么答案是 `N+1`，否则答案是 `[1,N]` 中没有出现的最小正整数。这样一来，我们将所有在 `[1,N]` 范围内的数放入哈希表，也可以得到最终的答案。而给定的数组恰好长度为 `N`，这让我们有了一种将数组设计成哈希表的思路：

我们对数组进行遍历，对于遍历到的数 `x`，如果它在 `[1,N]` 的范围内，那么就将数组中的第 `x−1` 个位置（注意：数组下标从 0 开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 `N+1`，否则答案是最小的没有打上标记的位置加 1。

那么如何设计这个「标记」呢？由于数组中的数没有任何限制，因此这并不是一件容易的事情。但我们可以继续利用上面的提到的性质：由于我们只在意 `[1,N]` 中的数，因此我们可以先对数组进行遍历，把不在 `[1,N]` 范围内的数修改成任意一个大于 `N` 的数（例如 `N+1`）。这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。算法的流程如下：

- 我们将数组中所有小于等于 0 的数修改为 `N+1`；
- 我们遍历数组中的每一个数 `x`，它可能已经被打了标记，因此原本对应的数为 `∣x∣`，其中 `|`为绝对值符号。如果 `∣x∣∈[1,N]`，那么我们给数组中的第 `∣x∣−1` 
个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；
- 在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 `N+1`，否则答案是第一个正数的位置加 1。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20201023203000.png)

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            if (nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }
        for (int i = 0; i < n; ++i) {
            int num = Math.abs(nums[i]);
            if (num <= n) {
                nums[num - 1] = -Math.abs(nums[num - 1]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```
### 解法二
1. 由于题目要求我们**只能使用常数级别的空间**，而要找的数一定在 `[1, N + 1]` 左闭右闭（这里 `N` 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组；
2. 我们要找的数就在 `[1, N + 1]` 里，最后 `N + 1` 这个元素我们不用找。因为在前面的 `N` 个元素都找不到的情况下，我们才返回 `N + 1`；
3. 那么，我们可以采取这样的思路：就把 `1` 这个数放到下标为 `0` 的位置， `2` 这个数放到下标为 `1` 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 `1` 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。
4. 这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 `i` 的数映射到下标为 `i-1` 的位置。

除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：

如果数组中包含 `x∈[1,N]`，那么恢复后，数组的第 `x−1` 个元素为 `x`。

在恢复后，数组应当有 `[1, 2, ..., N]` 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以`[3, 4, -1, 1]`为例，恢复后的数组应当为 `[1, -1, 3, 4]`，我们就可以知道缺失的数为 2。

那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 `x=nums[i]`，如果 `x∈[1,N]`，我们就知道 `x` 应当出现在数组中的 `x−1`的位置，因此交换 `nums[i]` 和 `nums[x−1]`，这样 `x` 就出现在了正确的位置。在完成交换后，新的 `nums[i]` 可能还在 `[1,N]` 的范围内，我们需要继续进行交换操作，直到 `x∉[1,N]`。

注意到上面的方法可能会陷入死循环。如果 `nums[i]` 恰好与 `nums[x−1]` 相等，那么就会无限交换下去。此时我们有 `nums[i]=x=nums[x−1]`，说明 `x` 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。

由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 `N`，整个方法的时间复杂度为 $O(N)$。

```java
public class Solution {

    public int firstMissingPositive(int[] nums) {
        int len = nums.length;

        for (int i = 0; i < len; i++) {
            while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
                // 满足在指定范围内、并且没有放在正确的位置上，才交换
                // 例如：数值 3 应该放在索引 2 的位置上
                swap(nums, nums[i] - 1, i);
            }
        }

        // [1, -1, 3, 4]
        for (int i = 0; i < len; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        // 都正确则返回数组长度 + 1
        return len + 1;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(N)$，这里 $N$ 是数组的长度。

说明：`while` 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。

最极端的一种情况是，在第 `1` 个位置经过这个 `while` 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 `for` 循环后面的部分的 `while` 的循环体都不会被执行。

平均下来，每个数只需要看一次就可以了，`while` 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做均摊复杂度分析。

最后再遍历了一次数组，最坏情况下要把数组里的所有的数都看一遍，因此时间复杂度是 `O(N)`。

- 空间复杂度：`O(1)`。

### 字节面试题解答
```java
class Solution {
    public int getMinimum(int[] nums,int k) {
        int n=nums.length;
        for(int i=0;i<n;i++){
            while(nums[i]>k&&nums[i]<k+n+1&&nums[nums[i]-k-1]!=nums[i]){
                swap(nums,nums[i]-k-1,i);
            }

        }
        for(int i=0;i<n;i++){
            if(nums[i]!=i+k+1){
                return i+k+1;
            }
        }
        return k+n+1;
    }
    public void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}
```
