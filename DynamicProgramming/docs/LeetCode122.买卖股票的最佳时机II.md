# [LeetCode122.买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
## 题目描述
给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 示例
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
## 题解
### 解法一
第 1 步：定义状态

状态 `dp[i][j]` 定义如下

- 第一维 `i` 表示索引为 `i` 的那一天（具有前缀性质，即考虑了之前天数的收益）能获得的最大利润；
- 第二维 `j` 表示索引为 `i` 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。

第 2 步：思考状态转移方程

- 状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；
- 每一天状态可以转移，也可以不动。状态转移用下图表示：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200903220438.png)

- 因为不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；
- 写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。

第 3 步：确定起始

- 如果什么都不做，`dp[0][0] = 0`；
- 如果买入股票，当前收益是负数，即 `dp[0][1] = -prices[i]`；

第 4 步：确定终止

终止的时候，上面也分析了，输出 `dp[len - 1][0]`，因为一定有 `dp[len - 1][0] > dp[len - 1][1]`。


```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int len=prices.length;
        int[][] dp=new int[len][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<len;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[len-1][0];
    }
}
```
状态压缩：
```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int len=prices.length;
        int[] dp=new int[2];
        dp[0]=0;
        dp[1]=-prices[0];
        for(int i=1;i<len;i++){
            dp[0]=Math.max(dp[0],dp[1]+prices[i]);
            dp[1]=Math.max(dp[1],dp[0]-prices[i]);
        }
        return dp[0];
    }
}
```
### 解法二
这道题使用贪心算法的流程是这样的：

从第 `i` 天（这里 `i >= 1`）开始，与第 `i - 1` 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ `prices[i] - prices[i- 1]`）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。

1、该算法仅可以用于计算，但计算的过程并不是真正交易的过程，但可以用贪心算法计算题目要求的最大利润。下面说明这个等价性：以 `[1, 2, 3, 4]` 为例，这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：

```java
res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])
    =  prices[3] - prices[0]
```

仔细观察上面的式子，按照贪心算法，在索引为 1、2、3 的这三天，我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，但是它等价于：“在索引为 0 的那一天买入，在索引为 3 的那一天卖出”。

股票买卖策略：

- 设今天价格 `p1`、明天价格 `p2`，则今天买入、明天卖出可赚取金额 `p2−p1`（负值代表亏损）。
- 连续上涨交易日： 设此上涨交易日股票价格分别为$p_{1}, p_{2}, \ldots, p_{n}$,则第一天买最后一天卖收益最大，即$p_{n}-p_{1}$,等价于每天都买卖，即$p_{n}-p_{1}=\left(p_{2}-p_{1}\right)+\left(p_{3}-p_{2}\right)+\ldots+\left(p_{n}-p_{n-1}\right)$
- 连续下降交易日： 则不买卖收益最大，即不会亏钱。

算法流程：

遍历整个股票交易日价格列表 `price`，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

- 设 `tmp` 为第 `i-1` 日买入与第 `i` 日卖出赚取的利润，即 `tmp = prices[i] - prices[i - 1]` ；
- 当该天利润为正 `tmp > 0`，则将利润加入总利润 `profit`；当利润为 0 或为负，则直接跳过；
- 遍历完成后，返回总利润 `profit`。


![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200903205409.png)

在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。这种方法将简化解决方案。
这个例子可以更清楚地展现上述情况：

`[1, 7, 2, 3, 6, 7, 6, 7]`

与此数组对应的图形是：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200903205706.png)

从上图中，我们可以观察到 `A+B+C` 的和等于差值 `D` 所对应的连续峰和谷的高度之差。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int ans=0;
        for(int i=1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                ans+=prices[i]-prices[i-1];
            }
        }
        return ans;
    }
}
```



