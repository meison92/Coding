# [LeetCode718.最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)
## 题目描述
给两个整数数组`A`和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

- `1 <= len(A), len(B) <= 1000`
- `0 <= A[i], B[i] < 100`
### 示例
```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```
## 题解
- 单看 `A` 、`B`数组的最后一项，如果它们俩不一样——以它们俩为末尾项形成的公共子数组的长度为0：`dp[i][j] = 0`
- 如果它们俩一样，以它们俩为末尾项的公共子数组，长度至少为 1——`dp[i][j]` 至少为 1，要考虑它们俩前缀数组「能为它们俩提供多大的公共长度——`dp[i-1][j-1]`
- 如果它们俩的前缀数组的「末尾项」不相同，即它们的前一项不相同，前缀数组提供的公共长度为 0——`dp[i-1][j-1] = 0`
- 以它们俩为末尾项的公共子数组的长度——`dp[i][j] = 0 + 1 = 1`
如果它们俩的前缀数组的「末尾项」相同

前缀部分能提供的公共长度—— `dp[i-1][j-1]`，它至少为 1

以它们俩为末尾项的公共子数组的长度 `dp[i][j] = dp[i-1][j-1] + 1`

题目求：最长的 公共子数组 的长度。不同的公共子数组的末尾项是不一样的。我们考察不同的末尾项的公共子数组，找出最长的那个。

`dp[i][j]` ：长度为 `i`，末尾项为 `A[i−1]` 的子数组，长度为 `j`，末尾项为 `B[j−1]` 的子数组，二者的最大公共后缀子数组长度。（即以 `A[i−1]`（`B[j−1]`）为末尾项的公共子数组）

- 如果 `A[i-1] != B[j-1]`， `dp[i][j] = 0`
- 如果 `A[i-1] == B[j-1]` ， `dp[i][j] = dp[i-1][j-1] + 1`

base case：如果`i==0 || j==0`，其中一个数组长度为 0，没有公共部分，`dp[i][j] = 0`

最长公共子数组以哪一项为末尾项都有可能，即每个 `dp[i][j]` 都可能是最大值。


```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int ans=0;
        int lenA=A.length,lenB=B.length;
        int[][] dp=new int[lenA+1][lenB+1];
        for(int i=1;i<lenA+1;i++){
            for(int j=1;j<lenB+1;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                    ans=Math.max(ans,dp[i][j]);
                }else{
                    dp[i][j]=0;
                }
            }
        }
        return ans;
    }
}
```
### 复杂度分析
- 时间复杂度： $O(N×M)$
- 空间复杂度： $O(N×M)$。

`N` 表示数组 `A` 的长度，`M` 表示数组 `B` 的长度。

