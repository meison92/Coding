# [LeetCode1024.视频拼接](https://leetcode-cn.com/problems/video-stitching/)
## 题目描述
你将会获得一系列视频片段，这些片段来自于一项持续时长为 `T` 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。

视频片段 `clips[i]` 都用区间进行表示：开始于 `clips[i][0]` 并于 `clips[i][1]` 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 `[0, 7]` 可以剪切成 `[0, 1] + [1, 3] + [3, 7]` 三部分。

我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（`[0, T]`）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。

- `1 <= clips.length <= 100`
- `0 <= clips[i][0] <= clips[i][1] <= 100`
- `0 <= T <= 100`
### 示例
```
输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
输出：3
解释：
我们选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
```
```
输入：clips = [[0,1],[1,2]], T = 5
输出：-1
解释：
我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
```
```
输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
输出：3
解释： 
我们选取片段 [0,4], [4,7] 和 [6,9] 。
```
```
输入：clips = [[0,4],[2,8]], T = 5
输出：2
解释：
注意，你可能录制超过比赛结束时间的视频。
```
## 题解
### 解法一
贪心
注意到对于所有左端点相同的子区间，其右端点越远越有利。且最佳方案中不可能出现两个左端点相同的子区间。于是我们预处理所有的子区间，对于每一个位置 `i`，我们记录以其为左端点的子区间中最远的右端点，记为 `maxn[i]`。

具体地，我们枚举每一个位置，假设当枚举到位置 `i` 时，记左端点不大于 `i` 的所有子区间的最远右端点为 `last`。这样 `last` 就代表了当前能覆盖到的最远的右端点。

每次我们枚举到一个新位置，我们都用 `maxn[i]` 来更新 `last`。如果更新后 `last==i`，那么说明下一个位置无法被覆盖，我们无法完成目标。

同时我们还需要记录上一个被使用的子区间的结束位置为 `pre`，每次我们越过一个被使用的子区间，就说明我们要启用一个新子区间，这个新子区间的结束位置即为当前的 `last`。也就是说，每次我们遇到 `i==pre`，则说明我们用完了一个被使用的子区间。这种情况下我们让答案加 1，并更新 `pre` 即可。

1. 首先来初始化一个 `maxEnd`数组，用于保存 以当前数字(下标)为起点 的区间的 最大的结束位置
2. 遍历`clips`，初始化`maxEnd`数组(每个元素开头的区间的最大结束位置)
3. 定义三个变量，辅助完成之后的操作：

   1. `pre` 记录 结果中上一次的最大结束位置(本轮的最小开始位置)
   2. `last` 记录 当前遍历到的 区间最大结束位置
   3. `count` 记录 结果

4. 根据`maxEnd`数组，计算最终结果

因为`maxEnd[i]`数组为最大结束位置，因此：

1. 当前元素 `==` 本区间最大元素，
即：区间断开，无法连续到后续位置，返回-1
2. 当前元素 `==` 上一个区间的最大结束元素，

即：到达了上一个满足条件的区间的结束位置

这时的`last`为当前最大的结束位置，我们将其放入满足条件的区间集合之中(因为本题只需要我们记录 满足条件的区间个数，因为只需要 更新`count`和`pre` 即可)


```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        if (clips == null) {
            return 0;
        }

        int[] maxEnd = new int[T];  // 用于保存 以当前数字(下标)为起点 的区间的 最大的结束位置

        /*
            遍历clips，初始化maxEnd数组(每个元素开头的区间的最大结束位置)
         */
        for (int[] clip : clips) {
            if (clip[0] < T) {
                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);
            }
        }

        /*
            根据maxEnd数组，计算最终结果
                因为maxEnd[i]数组为最大结束位置，因此：
                    1、当前元素 == 本区间最大元素，
                        即：区间断开，无法连续到后续位置，返回-1
                    2、当前元素 == 上一个区间的最大结束元素，
                        即：到达了上一个满足条件的区间的结束位置
                        这时的last为当前最大的结束位置，我们将其放入满足条件的区间集合之中
                        (因为本题只需要我们记录 满足条件的区间个数，因为只需要 更新count和pre 即可)
         */
        int pre = 0;    // 记录 结果中上一次的最大结束位置(本轮的最小开始位置)
        int last = 0;   // 记录当前遍历到的 区间最大结束位置
        int count = 0; // 记录结果
        for (int i = 0; i < T; i++) {
            last = Math.max(maxEnd[i], last);
            if (i == last) {    // 当前元素 == 本区间最大元素(无法到达后续位置)
                return -1;
            }

            if (i == pre) { // 当前元素 == 上一个区间的最大元素
                count++;
                pre = last;
            }
        }
        return count;
    }
}
```
自己的写法：
```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int len=clips.length;
        Arrays.sort(clips,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                if(a[0]!=b[0]){
                    return a[0]-b[0];
                }else{
                    return b[1]-a[1];
                }
            }
        });
        if(clips[0][0]!=0){
            return -1;
        }
        int cnt=1;
        int max=clips[0][1];
        if(max>=T){
            return cnt;
        }
        int i=1;
        while(i<len){
            if(clips[i][0]>max){
                return -1;
            }
            int maxTemp=max;
            while(i<len&&clips[i][0]<=maxTemp){
                max=Math.max(max,clips[i][1]);
                i++;
            }
            if(max>maxTemp){
                cnt++;
            }
            if(max>=T){
                return cnt;
            }
        }
        return -1;
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(T+N)$，其中 `T` 是区间的长度，`N` 是子区间的数量。我们需要枚举每一个位置，时间复杂度 $O(T)$，同时我们还需要预处理所有的子区间，时间复杂度 $O(N)$。总时间复杂度为 $O(T)+O(N)=O(T+N)$。

- 空间复杂度：$O(T)$，其中 `T` 是区间的长度。对于每一个位置，我们需要记录以其为左端点的子区间的最右端点。

### 
`DP`:
我们令 `dp[i]` 表示将区间 `[0,i)` 覆盖所需的最少子区间的数量。由于我们希望子区间的数目尽可能少，因此可以将所有 `dp[i]` 的初始值设为一个大整数，并将 `dp[0]`（即空区间）的初始值设为 0。

我们可以枚举所有的子区间来依次计算出所有的 `dp` 值。我们首先枚举 `i`，同时对于任意一个子区间 `[aj,bj)`，若其满足 `aj<i≤bj`，那么它就可以覆盖区间 `[0,i)` 的后半部分，而前半部分则可以用 `dp[aj]` 对应的最优方法进行覆盖，因此我们可以用 `dp[aj]+1`来更新 `dp[i]`状态转移方程如下：

`dp[i]=min{dp[aj]}+1(aj<i≤bj)`

```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp, Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for (int i = 1; i <= T; i++) {
            for (int[] clip : clips) {
                if (clip[0] < i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE - 1 ? -1 : dp[T];
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(T×N)$，其中 `T` 是区间的长度，`N` 是子区间的数量。对于任意一个前缀区间 `[0,i)`，我们都需要枚举所有的子区间，时间复杂度 $O(N)$。总时间复杂度为 $O(T)×O(N)=O(T×N)$。
- 空间复杂度：$O(T)$，其中 `T` 是区间的长度。我们需要记录每一个前缀区间 `[0,i)` 的状态信息。