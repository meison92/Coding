# [LeetCode300.最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
## 题目描述
给定一个无序的整数数组，找到其中最长上升子序列的长度。
- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 $O(n^2)$ 。

进阶: 你能将算法的时间复杂度降低到 $O(nlogn)$ 吗?
### 示例
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
## 题解
### 解法一
状态定义：`dp[i]` 的值代表 `nums` 前 `i` 个数字的最长子序列长度。

转移方程： 设 `j∈[0,i)`，考虑每轮计算新 `dp[i]` 时，遍历 `[0,i)` 列表区间，做以下判断：

- 当 `nums[i]>nums[j]` 时： `nums[i]` 可以接在 `nums[j]` 之后（此题要求严格递增），此情况下最长上升子序列长度为 `dp[j]+1`；
- 当 `nums[i]<=nums[j]` 时： `nums[i]` 无法接在 `nums[j]` 之后，此情况上升子序列不成立，跳过。

上述所有 1. 情况下计算出的 `dp[j]+1` 的最大值，为直到 `i` 的最长上升子序列长度（即 `dp[i]` ）。实现方式为遍历 `j` 时，每轮执行 `dp[i]=max(dp[i],dp[j]+1)`。

转移方程： `dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)`。

初始状态：`dp[i]` 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。

返回值：返回 `dp` 列表最大值，即可得到全局最长上升子序列长度。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums==null||nums.length==0){
            return 0;
        }
        int[] dp=new int[nums.length];
        int ans=1;
        for(int i=0;i<nums.length;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            ans=ans>dp[i]?ans:dp[i];
        }
        return ans;
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(n^2)$，遍历计算 `dp` 列表需 $O(N)$，计算每个 `dp[i]` 需 $O(N)$。
- 空间复杂度：$O(n)$，需要额外使用长度为 `n` 的 `dp` 数组。
### 解法二
降低复杂度切入点： 解法一中，遍历计算 `dp` 列表需 $O(N)$，计算每个 `dp[k]` 需 $O(N)$。

- 动态规划中，通过线性遍历来计算 `dp` 的复杂度无法降低；
- 每轮计算中，需要通过线性遍历 `[0,k)` 区间元素来得到 `dp[k]` 。我们考虑：是否可以通过重新设计状态定义，使整个 `dp` 为一个排序列表；这样在计算每个 `dp[k]` 时，就可以通过二分法遍历 `[0,k)` 区间元素，将此部分复杂度由 $O(N)$ 降至 $O(logN)$。

设计思路：

新的状态定义：

- 我们考虑维护一个列表 `dp`，其中每个元素 `dp[k]` 的值代表 长度为 `k+1` 的子序列尾部元素的值。
- 如 `[1,4,6]` 序列，长度为 `1,2,3` 的子序列尾部元素值分别为 `dp=[1,4,6]`。

状态转移设计：
- 在遍历计算每个 `dp[k]`，不断更新长度为 `[1,k]` 的子序列尾部元素值，始终保持每个尾部元素值最小 （例如 `[1,5,3]`， 遍历到元素 5 时，长度为 2 的子序列尾部元素值为 5；当遍历到元素 3 时，尾部元素值应更新至 3，因为 3 遇到比它大的数字的几率更大）。
- `dp` 列表一定是严格递增的： 即当尽可能使每个子序列尾部元素值最小的前提下，子序列越长，其序列尾部元素值一定更大。 
  - 既然严格递增，每轮计算 `dp[k]` 时就可以使用二分法查找需要更新的尾部元素值的对应索引 `i`。

算法流程：

状态定义：

- `dp[k]` 的值代表 长度为 `k+1` 子序列 的尾部元素值。

转移方程： 设 `res` 为 `dp` 当前长度，代表直到当前的最长上升子序列长度。设 `j∈[0,res]`，考虑每轮遍历 `nums[k]` 时，通过二分法遍历 `[0,res]`列表区间，找出 `nums[k]` 的大小分界点，会出现两种情况：

1. 区间中存在 `dp[i]>nums[k]`： 将第一个满足 `dp[i]>nums[k]` 执行 `dp[i]=nums[k]`；因为更小的 `nums[k]` 后更可能接一个比它大的数字（前面分析过）。
2. 区间中不存在 `dp[i]>nums[k]`： 意味着 `nums[k]` 可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 `res` ），新子序列长度为 `res+1`。


另一种解释：

从一个例子开始。我们先考虑下面的数组的最长上升子序列：

[10, 9, 2, 5, 3, 7, 101, 4, 1]

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200825215917.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200825215952.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200825220001.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200825220024.png)

- 假如我们要在里面新增一个元素 `X`，希望找出插入 `X` 之后的最长子序列。
- 结论一指出，我们需要在当前允许插入的 最长 子序列之后添加元素。
- 于是，我们可以依次检查`序列长度 = 1,2,3,4`的递增子序列，然后找出最长的，`尾数 < X` 的序列。
- 我们发现，对每一个序列长度 `l`，只需要检查图中的每一列的最小值（绿色的元素）是否 `< X` 即可。如果绿色的元素 `< X`，表明长度为 `l` 的递增子序列后可添加元素 `X`。
- 因此，我们有 结论二：我们只需要维护 长度为 `l` 的递增子序列的 最小结尾数字。
- 这样，我们得到了一个数组 `[1,3,4,101]`。这就是题解中的 `d` 数组。
- 对于这样的 `d` 数组，我们有 结论3：`d` 数组一定是 [严格递增] 的。因为 `d[i]` 为 长度为 `i+1` 的递增子序列末尾的最小数字，而当 `i>=1`时，长度为 `i+1` 的递增子序列一定是由长度为 `i` 的递增子序列添加元素而来，如果长度为 `i` 的递增子序列的 [最小尾数] 为 `X`，则添加的元素一定 `>X`。

最简单的实现方式，当插入新元素 `X` 时，我们从 1 逐个枚举现有递增子序列的长度，直到找到最大可添加元素 `X` 的长度。与此同时，维护每个长度 `l` 的最小尾数：

比如前述序列 `[10,9,2,5,3,7,101,4,1]`，已构造 `d` 数组 `[1,3,4,101]`，要添加 “6”。

- 长度 `l=1`时，长度为 1 的递增子序列末尾的最小数字为 1，`6>1`，可以添加。
- `l=2` 时，`6>3`，可以添加。
- `l=3` 时，`6>4`，可以添加。
- `l=4`时，`6<101`，不可添加。
- 因此，以 `6`为结尾的递增子序列最长为 `3+1=4`。
- 另外，此时，长度为 4 的递增子序列的最小尾数变成了`6`。因此修改 `“101”−>“6”`。数组变为 `[1,3,4,6]`。

如果要添加 `“102”` 呢？

- 由于 `“102”>“101”`，因此 `“102”`可以在长度为 4 的子序列后添加，递增子序列的最大长度变成了 5。
- 由于长度为 5 的递增子序列的尾数只有 `“102”`，故最小尾数也是 `“102”`，直接在数组后添加 `“102”` 即可。

优化：

- 由于数组是有序的，当要添加数 `“x”` 时，可以用二分搜索找出数组中小于 `x` 的最大数字，及其对应的下标 `i`。
- 另外，若 `d[i]<x`，则 `d[i+1]>=x`。因此需要将 `d[i+1]` 修改为 `x`，代表长度为 `i+2` 的递增子序列末尾的最小数字。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums==null||nums.length==0){
            return 0;
        }
        int[] dp=new int[nums.length];
        dp[0]=nums[0];
        int maxLen=1;
        for(int i=1;i<nums.length;i++){
            int idx=binarySearch(dp,maxLen,nums[i]);
            if(idx==maxLen){
                dp[maxLen]=nums[i];
                maxLen++;
            }
            if(idx<maxLen){
                dp[idx]=nums[i];
            }
        }
        return maxLen;
    }
    public int binarySearch(int[] nums,int end,int target){
        int left=0,right=end;
        while(left<right){
            int mid=left+(right-left)/2;
            if(nums[mid]>=target){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(nlogn)$。数组 `nums`的长度为 `n`，我们依次用数组中的元素去更新 `d` 数组，而更新 `d` 数组时需要进行 $O(logn)$的二分搜索，所以总时间复杂度为 $O(nlogn)$。
- 