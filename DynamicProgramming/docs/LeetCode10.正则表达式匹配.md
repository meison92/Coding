# [LeetCode10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
## 题目描述
给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 `s`的，而不是部分字符串。

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

### 示例
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```
```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```
```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```
```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```
## 题解
假设主串为 `A`，模式串为 `B` 从最后一步出发，需要关注最后进来的字符。假设 `A` 的长度为 `n` ，`B` 的长度为 `m` ，关注正则表达式 `B` 的最后一个字符是谁，它有三种可能，正常字符、`*` 和 `.`（点），那针对这三种情况讨论即可，如下：

1. 如果 `B` 的最后一个字符是正常字符，那就是看 `A[n−1]` 是否等于 `B[m−1]`，相等则看 `A[0...n-2]`与 `B[0...m-2]` ，不等则是不能匹配，这就是子问题。
2. 如果 `B` 的最后一个字符是`.`，它能匹配任意字符，直接看 `A[0...n-2]`与 `B[0...m-2]`
3. 如果 `B` 的最后一个字符是`*`它代表 `B[m−2]=c` 可以重复0次或多次，它们是一个整体 `c∗`
   1. 情况一：`A[n−1]` 是 0 个 `c`，`B` 最后两个字符废了，能否匹配取决于 `A[0..n−1]`和 `B[0..m−3]`是否匹配
   2. 情况二：`A[n−1]` 是多个 `c` 中的最后一个（这种情况必须 `A[n−1]=c` 或者 `c='.'`），所以 `A` 匹配完往前挪一个，`B` 继续匹配，因为可以匹配多个，继续看 `A[0..n−2`和 `B[0..m−1]`是否匹配。

`dp[i][j]` 代表 `A` 的前 `i` 个和 `B` 的前 `j` 个能否匹配

- 对于前面两个情况，可以合并成一种情况 `dp[i][j]=dp[i−1][j−1]`
- 对于第三种情况，对于 `c*` 分为看和不看两种情况
  - 不看：直接砍掉正则串的后面两个， `dp[i][j]=dp[i][j−2]`
  - 看：正则串不动，主串前移一个，`dp[i][j]=dp[i−1][j]`

初始条件

特判：需要考虑空串空正则

- 空串和空正则是匹配的，`dp[0][0]=true`
- 空串和非空正则，不能直接定义 `true` 和 `false`，必须要计算出来。（比如`A= ''`,`B=a*b*c*`）
- 非空串和空正则必不匹配，`dp[1][0]=...=dp[n][0]=false`
- 非空串和非空正则，那肯定是需要计算的了。

大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 `*` 和不是 `*` 两种情况了。

结果

我们开数组要开 `n+1` ，这样对于空串的处理十分方便。结果就是 `dp[n][m]`

```java
class Solution {
    public boolean isMatch(String A, String B) {
        int n = A.length();
        int m = B.length();
        char[] arrA=A.toCharArray();
        char[] arrB=B.toCharArray();
        boolean[][] dp = new boolean[n + 1][m + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                //分成空正则和非空正则两种
                if (j == 0) {
                    dp[i][j] = i == 0;
                } else {
                    //非空正则分为两种情况 * 和 非*
                    if (arrB[j - 1]!= '*') {
                        if (i > 0 && (arrA[i - 1]== arrB[j - 1]|| arrB[j - 1] == '.')) {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    } else {
                        //碰到 * 了，分为看和不看两种情况
                        //不看
                        if (j >= 2) {
                            dp[i][j] |= dp[i][j - 2];
                        }
                        //看
                        if (i >= 1 && j >= 2 && (arrA[i - 1]== arrB[j - 2]|| arrB[j - 2]== '.')) {
                            dp[i][j] |= dp[i - 1][j];
                        }
                    }
                }
            }
        }
        return dp[n][m];
    }
}
```
### 复杂度分析
- 时间复杂度：$O(mn)$，其中 `m` 和 `n` 分别是字符串 `s` 和 `p` 的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 $O(1)$。
- 空间复杂度：$O(mn)$，即为存储所有状态使用的空间。
