# [LeetCode856.括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)
## 题目描述
给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 `A` 和 `B` 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 `A` 是平衡括号字符串。

- `S` 是平衡括号字符串，且只含有 `(` 和 `)` 。
- `2 <= S.length <= 50`

### 示例
```
输入： "()"
输出： 1
```
```
输入： "(())"
输出： 2
```
```
输入： "()()"
输出： 2
```
```
输入： "(()(()))"
输出： 6
```
## 题解
字符串 `S` 中的每一个位置都有一个“深度”，即该位置外侧嵌套的括号数目。例如，字符串 `(()(.()))` 中的 `.` 的深度为 2，因为它外侧嵌套了 2 层括号：`(__(.__))`。

我们用一个栈来维护当前所在的深度，以及每一层深度的得分。当我们遇到一个左括号 `(` 时，我们将深度加一，并且新的深度的得分置为 0。当我们遇到一个右括号 `)` 时，我们将当前深度的得分乘二并加到上一层的深度。这里有一种例外情况，如果遇到的是 `()`，那么只将得分加一。

下面给出了字符串 `(()(()))` 每次对应的栈的情况：
```
[0, 0] (
[0, 0, 0] ((
[0, 1] (()
[0, 1, 0] (()(
[0, 1, 0, 0] (()((
[0, 1, 1] (()(()
[0, 3] (()(())
[6] (()(()))
```
```java
class Solution {
    public int scoreOfParentheses(String S) {
        Deque<Integer> stack=new LinkedList<>();
        char[] arr=S.toCharArray();
        stack.push(0);
        for(char c:arr){
            if(c=='('){
                stack.push(0);
            }else{
                int v=stack.pop();
                int w=stack.pop();
                stack.push(w+Math.max(2*v,1));
            }
        }
        return stack.pop();
    }
}
```
### 复杂度分析
- 时间复杂度：$O(N)$，其中 `N` 是字符串 `S` 的长度。
- 空间复杂度：$O(N)$，为栈的大小。