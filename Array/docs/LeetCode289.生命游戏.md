# [LeetCode289.生命游戏](https://leetcode-cn.com/problems/game-of-life/)
## 题目描述
根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 `m×n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

- 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
- 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
- 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
- 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

- 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
- 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？
### 示例
```
输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```
## 题解
### 解法一
题目中每个细胞只有两种状态 `live(1)` 或 `dead(0)`，但我们可以拓展一些复合状态使其包含之前的状态。举个例子，如果细胞之前的状态是 0，但是在更新之后变成了 1，我们就可以给它定义一个复合状态 2。这样我们看到 2，既能知道目前这个细胞是活的，还能知道它之前是死的。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20201029222113.png)

算法

遍历 board 中的细胞。

根据数组的细胞状态计算新一轮的细胞状态，这里会用到能同时代表过去状态和现在状态的复合状态。

具体的计算规则如下所示：

- 规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；
- 规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；
- 规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；
- 规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。

根据新的规则更新数组；

现在复合状态隐含了过去细胞的状态，所以我们可以在不复制数组的情况下完成原地更新；

对于最终的输出，需要将 `board` 转成 0，1 的形式。因此这时候需要再遍历一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。
```java
class Solution {
    public void gameOfLife(int[][] board) {
        int m=board.length,n=board[0].length;
        int[][] helper=new int[m][n];
        for(int i=0;i<m;i++){
            helper[i]=Arrays.copyOf(board[i],n);
        }
        int[][] dirs={{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,-1},{1,1}};
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==1){
                    int cnt=0;
                    for(int k=0;k<8;k++){
                        int newI=i+dirs[k][0],newJ=j+dirs[k][1];
                        if(newI>=0&&newI<m&&newJ>=0&&newJ<n){
                            if(helper[newI][newJ]==1){
                                cnt++;
                            }
                        }
                    }
                    if(cnt<2||cnt>3){
                        board[i][j]=0;
                    }
                }else{
                    int cnt=0;
                    for(int k=0;k<8;k++){
                        int newI=i+dirs[k][0],newJ=j+dirs[k][1];
                        if(newI>=0&&newI<m&&newJ>=0&&newJ<n){
                            if(helper[newI][newJ]==1){
                                cnt++;
                            }
                        }
                    }
                    if(cnt==3){
                        board[i][j]=1;
                    }
                }
            }
        }
    }
}
```
### 复杂度分析
- 时间复杂度：$O(mn)$，其中 `m`，`n` 分别为 `board` 的行数和列数。
- 空间复杂度：$O(1)$，除原数组外只需要常数的空间存放若干变量。

### 解法二
```java
class Solution {
    public void gameOfLife(int[][] board) {
        int m=board.length,n=board[0].length;
        int[][] helper=new int[m][n];
        for(int i=0;i<m;i++){
            helper[i]=Arrays.copyOf(board[i],n);
        }
        int[][] dirs={{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,-1},{1,1}};
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==1){
                    int cnt=0;
                    for(int k=0;k<8;k++){
                        int newI=i+dirs[k][0],newJ=j+dirs[k][1];
                        if(newI>=0&&newI<m&&newJ>=0&&newJ<n){
                            if(helper[newI][newJ]==1){
                                cnt++;
                            }
                        }
                    }
                    if(cnt<2||cnt>3){
                        board[i][j]=0;
                    }
                }else{
                    int cnt=0;
                    for(int k=0;k<8;k++){
                        int newI=i+dirs[k][0],newJ=j+dirs[k][1];
                        if(newI>=0&&newI<m&&newJ>=0&&newJ<n){
                            if(helper[newI][newJ]==1){
                                cnt++;
                            }
                        }
                    }
                    if(cnt==3){
                        board[i][j]=1;
                    }
                }
            }
        }
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(mn)$，其中 `m` 和 `n` 分别为 `board` 的行数和列数。
- 空间复杂度：$O(mn)$，为复制数组占用的空间。
