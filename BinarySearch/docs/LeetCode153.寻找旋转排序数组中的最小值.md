# [LeetCode153.寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
## 题目描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

### 示例
```
输入: [3,4,5,1,2]
输出: 1
```
```
输入: [4,5,6,7,0,1,2]
输出: 0
```
## 题解
旋转排序数组 `nums` 可以被拆分为 2 个排序数组 `nums1` , `nums2`，并且 `nums1任一元素 >= nums2任一元素`；因此，考虑二分法寻找此两数组的分界点 `nums[i]` (即第 2 个数组的首个元素)。

设置 `left`, `right` 指针在 `nums` 数组两端，`mid` 为每次二分的中点：

1. 当 `nums[mid] > nums[right]`时，`mid` 一定在第 1 个排序数组中，`i` 一定满足 `mid < i <= right`，因此执行 `left = mid + 1`；
2. 当 `nums[mid] < nums[right]` 时，`mid` 一定在第 2 个排序数组中，`i` 一定满足 `left < i <= mid`，因此执行 `right = mid`；
```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[right]){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return nums[left];
    }
}
```

### 复杂度分析
- 时间复杂度 $O(logN)$，在特例情况下会退化到 $O(N)$（例如 `[1,1,1,1]`）。

#### 补充说明1:

只要是一次可以排除一半，都可以用二分法。那么如何使用二分法呢？我们很自然会想到使用边界的值和中间位置的值进行比较。

注意：这里的提法是“中间数”，即位于中间的那个数，不是中位数，请注意区分。

可以分为以下两种情况：

1. 中间数与左边界比较

尝试在纸上写出几个例子：

例 1：`[1, 2, 3, 4, 5]`

例 2：`[2, 3, 4, 5, 1]`

以上这两个例子，中间数都比左边界大，但是旋转排序数组的最小值可能在中间数的左边（例 1），也可能在中间数的右边（例 2），因此不能使用中间数与左边界比较作为二分法的讨论依据。

接下来，看看另一种讨论依据。

2. 中间数与右边界比较：
   1. 当中间数比右边界表示的数大的时候，中间数就一定不是目标数（旋转排序数组的最小值）。

还是尝试举个例子：

例 3：`[7, 8, 9, 10, 11, 12, 1, 2, 3]`

中间数 11 比右边界 3 大，因此中间数以及中间数前面的数都不是目标数，把左边界设置中间数位置 + 1，即 `left = mid + 1`；

   2. 当中间数比右边界表示的数小的时候，中间数就可能是目标数（旋转排序数组的最小值），举个例子：

例 4：`[7, 8, 1, 2, 3]`

中间数 1 比右边界表示的数小的时候，说明，中间数到右边界是递增的（对于这道题是非递减），那么中间数右边的（不包括中间数）就一定不是目标数，可以把它们排除，不过中间数有可能是目标数，就如本例，因此，把右边界设置为 `right = mid`。

#### 补充说明2
首先说一下主要思路：

单调递增的序列：

```
        *
      *
    *
  *
*
```

做了旋转：

```
  *
*
        *
      *
    *
```

用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。

左、中、右三个位置的值相比较，有以下几种情况：

1. 左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界
```
        右
     中
 左
```
2. 左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界
```
 左       
         右
     中
```
3. 左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界
```
    中  
 左 
         右
```
4. 左值 > 中值, 中值 > 右值 ：单调递减，不可能出现
```
 左
    中
        右
```
分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。

1. 如果中值 < 右值，则最小值在左半边，可以收缩右边界。
2. 如果中值 > 右值，则最小值在右半边，可以收缩左边界。
3. 通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。

而情况1与情况3都是左值 < 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。

所以我们需要通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。

接着分析解法里的一些问题：

首先是while循环里的细节问题。

这里的循环不变式是`left < right`, 并且要保证左闭右开区间里面始终套住最小值。

中间位置的计算：`mid = left + (right - left) / 2`这里整数除法是向下取整的地板除，`mid`更靠近`left`，再结合`while`循环的条件`left < right`，可以知道`left <= mid`，`mid < right`，即在`while`循环内，`mid`始终小于`right`。

因此在`while`循环内，`nums[mid]`要么大于要么小于`nums[right]`，不会等于。

这样`else {right = mid;}`这句判断可以改为更精确的`else if (nums[mid] < nums[right]) {right = mid;}`。

再分析一下`while`循环退出的条件。

如果输入数组只有一个数，左右边界位置重合，`left == right`，不会进入`while`循环，直接输出。

如果输入数组多于一个数，循环到最后，会只剩两个数，`nums[left] == nums[mid]`，以及`nums[right]`，这里的位置`left == mid == right - 1`。

如果`nums[left] == nums[mid] > nums[right]`，则左边大、右边小，需要执行`left = mid + 1`，使得`left == right`，左右边界位置重合，循环结束，`nums[left]`与`nums[right]`都保存了最小值。

如果`nums[left] == nums[mid] < nums[right]`，则左边小、右边大，会执行`right = mid`，使得`left == right`，左右边界位置重合，循环结束，`nums[left]`、`nums[mid]`、`nums[right]`都保存了最小值。

细化了的代码：
```java
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;                /* 左闭右闭区间，如果用右开区间则不方便判断右值 */ 
        while (left < right) {                      /* 循环不变式，如果left == right，则循环结束 */
            int mid = left + (right - left) / 2;    /* 地板除，mid更靠近left */
            if (nums[mid] > nums[right]) {          /* 中值 > 右值，最小值在右半边，收缩左边界 */ 
                left = mid + 1;                     /* 因为中值 > 右值，中值肯定不是最小值，左边界可以跨过mid */ 
            } else if (nums[mid] < nums[right]) {   /* 明确中值 < 右值，最小值在左半边，收缩右边界 */ 
                right = mid;                        /* 因为中值 < 右值，中值也可能是最小值，右边界只能取到mid处 */ 
            }
        }
        return nums[left];    /* 循环结束，left == right，最小值输出nums[left]或nums[right]均可 */     
    }
};
```

再讨论一个问题：

为什么左右不对称？为什么比较`mid`与`right`而不比较`mid`与`left`？能不能通过比较`mid`与`left`来解决问题？

左右不对称的原因是：这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。












