# [剑指Offer11.旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
## 题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。  

### 示例
```
输入：[3,4,5,1,2]
输出：1
```
```
输入：[2,2,2,0,1]
输出：0
```
## 题解
旋转排序数组 `nums` 可以被拆分为 2 个排序数组 `nums1` , `nums2`，并且 `nums1任一元素 >= nums2任一元素`；因此，考虑二分法寻找此两数组的分界点 `nums[i]` (即第 2 个数组的首个元素)。

设置 `left`, `right` 指针在 `nums` 数组两端，`mid` 为每次二分的中点：

1. 当 `nums[mid] > nums[right]`时，`mid` 一定在第 1 个排序数组中，`i` 一定满足 `mid < i <= right`，因此执行 `left = mid + 1`；
2. 当 `nums[mid] < nums[right]` 时，`mid` 一定在第 2 个排序数组中，`i` 一定满足 `left < i <= mid`，因此执行 `right = mid`；
3. 当 `nums[mid] == nums[right]` 时，是此题的难点（原因是此题中数组的元素可重复，难以判断分界点 `i` 指针区间）
   1. 例如 `[1,0,1,1,1]` 和 `[1,1,1,0,1]`，在 `left = 0`, `right = 4`, `mid = 2` 时，无法判断 `mid` 在哪个排序数组中。 
   2. 我们采用 `right = right - 1` 解决此问题，证明：
      1. 此操作不会使数组越界：因为迭代条件保证了 `right > left >= 0`；
      2. 此操作不会使最小值丢失：假设 `nums[right]` 是最小值，有两种情况：
         1. 若 `nums[right]` 是唯一最小值：那就不可能满足判断条件 `nums[mid] == nums[right]`，因为 `mid < right`（`left != right` 且 `mid = (left + right) // 2` 向下取整）； 
         2. 若 `nums[right]` 不是唯一最小值，由于 `mid < right` 而 `nums[mid] == nums[right]`，即还有最小值存在于 `[left,right−1]`区间，因此不会丢失最小值。
4. 以上是理论分析，可以代入以下数组辅助思考：
   - [1,2,3]
   - [1,1,0,1]
   - [1,0,1,1,1]
   - [1,1,1,1]

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if(nums[mid]==nums[right]){
                right--;
                continue;
            }
            if (nums[mid] > nums[right]){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return nums[left];
    }
}
```
### 复杂度分析
- 时间复杂度 $O(logN)$，在特例情况下会退化到 $O(N)$（例如 `[1,1,1,1]`）。
  
补充说明:

只要是一次可以排除一半，都可以用二分法。那么如何使用二分法呢？我们很自然会想到使用边界的值和中间位置的值进行比较。

注意：这里的提法是“中间数”，即位于中间的那个数，不是中位数，请注意区分。

可以分为以下两种情况：

1. 中间数与左边界比较

尝试在纸上写出几个例子：

例 1：`[1, 2, 3, 4, 5]`

例 2：`[2, 3, 4, 5, 1]`

以上这两个例子，中间数都比左边界大，但是旋转排序数组的最小值可能在中间数的左边（例 1），也可能在中间数的右边（例 2），因此不能使用中间数与左边界比较作为二分法的讨论依据。

接下来，看看另一种讨论依据。

2. 中间数与右边界比较：
   1. 当中间数比右边界表示的数大的时候，中间数就一定不是目标数（旋转排序数组的最小值）。

还是尝试举个例子：

例 3：`[7, 8, 9, 10, 11, 12, 1, 2, 3]`

中间数 11 比右边界 3 大，因此中间数以及中间数前面的数都不是目标数，把左边界设置中间数位置 + 1，即 `left = mid + 1`；

   2. 当中间数比右边界表示的数小的时候，中间数就可能是目标数（旋转排序数组的最小值），举个例子：

例 4：`[7, 8, 1, 2, 3]`

中间数 1 比右边界表示的数小的时候，说明，中间数到右边界是递增的（对于这道题是非递减），那么中间数右边的（不包括中间数）就一定不是目标数，可以把它们排除，不过中间数有可能是目标数，就如本例，因此，把右边界设置为 `right = mid`。

   3. 当中间数与右边界表示的数相等的时候，看下面两个例子：

例 5：`[0, 1, 1, 1, 1, 1, 1]`

例 6：`[1, 1, 1, 1, 0, 1, 1]`

目标值可能在中间数的左边，也可能在中间数的右边，那么该怎么办呢？很简单，此时你看到的是右边界，就把只右边界排除掉就好了。正是因为右边界和中间数相等，你去掉了右边界，中间数还在，就让中间数在后面的循环中被发现吧。

因此，根据中间数和右边界的大小关系，可以使用二分法搜索到目标值。