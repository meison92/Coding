# [LeetCode7.整数反转](https://leetcode-cn.com/problems/reverse-integer/)
## 题目描述
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 `[−2^31,  2^31−1]`。请根据这个假设，如果反转后整数溢出那么就返回 0。

### 示例
```
输入: 123
输出: 321
```
```
输入: -123
输出: -321
```
```
输入: 120
输出: 21
```
## 题解
弹出和推入数字 `&` 溢出前进行检查

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

反转整数的方法可以与反转字符串进行类比。

我们想重复“弹出” `x` 的最后一位数字，并将它“推入”到 `rev` 的后面。最后，`rev` 将与 `x` 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```java
//pop operation:
pop = x % 10;
x /= 10;

//push operation:
temp = rev * 10 + pop;
rev = temp;
```

但是，这种方法很危险，因为当 `temp=rev⋅10+pop`时会导致溢出。

幸运的是，事先检查这个语句是否会导致溢出很容易。

为了便于解释，我们假设 `rev` 是正数。

1. 如果 `temp=rev⋅10+pop`导致溢出，那么一定有 `rev≥INTMAX/10`
2. 如果 `rev>INTMAX/10`，那么 `temp=rev⋅10+pop`一定会溢出。
3. 如果 `rev==INTMAX/10`，那么只要 `pop>7`，`temp=rev⋅10+pop`就会溢出。

循环的判断条件应该是`while(x!=0)`，无论正数还是负数，按照上面不断的/10这样的操作，最后都会变成0，所以判断终止条件就是!=0

假设有1147483649这个数字，它是小于最大的32位整数2147483647的，但是将这个数字反转过来后就变成了9463847411，这就比最大的32位整数还要大了，这样的数字是没法存到int里面的，所以肯定要返回0(溢出了)。

甚至，我们还需要提前判断

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200929141026.png)

上图中，绿色的是最大32位整数

第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。

所以，我们到【最大数的1/10】时，就要开始判断了

如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。

如果某个数字等于 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。

对于负数也是一样的

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200929141106.png)

上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断

如果某个数字小于 -214748364说明溢出了

如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于-8


```java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
}
```
### 复杂度分析
- 时间复杂度：$O(log(x))$，`x` 中大约有 $log10(x)$位数字。
- 空间复杂度：$O(1)$。
