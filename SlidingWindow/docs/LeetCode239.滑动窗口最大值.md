# [LeetCode239.滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
## 题目描述
给定一个数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

你能在线性时间复杂度内解决此题吗？

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

### 示例
```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
## 题解
### 解法一
我们先看什么是单调的双向队列，双向队列大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的单调，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。如下所示：
```
头部                      尾部
 --------------------------
|  5   3   2   1   0  -1   |
 --------------------------
  由大     →       到小
```
也就是说，我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：

- 如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
- 如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。

在不规定窗口大小的前提下，我们先看看如何将新元素添加到单调的双向队列中。假如有5、4、1、2、6要进入单调的双向队列，首先让索引为0的元素5进入，由于之前队列是空的，所以5直接进去即可，如下所示：
```
头部                    尾部
 --------------------------
|  5                      |
|  ↑                     |
|  0                      |
 --------------------------
  大                  小
```
此时，索引1位置上的4要进队列，则需要比较队列尾部与4的大小关系。由于5是大于4的，并且4从尾部进去以后能够满足从头到尾、从大到小的规定，所以我们让4进去即可，如下所示：
```
头部                    尾部
 --------------------------
|  5    4                 |
|  ↑   ↑                |
|  0    1                 |
 --------------------------
  大                  小

```
然后，索引2位置上的元素1也想要进去，根据我们的规定，让它直接进入就好了，如下所示：

```
头部                    尾部
 --------------------------
|  5    4    1            |
|  ↑   ↑   ↑           |
|  0    1    2            |
 --------------------------
  大                  小
  ```
然后，索引3位置上的元素2想要进去，此时，由于尾部的元素1是小于元素2的，2进去以后不满足从大到小的规定，所以让1从尾部出来，直接丢掉它，然后再让元素2从尾部进入，如下所示：

```
头部                    尾部
 --------------------------
|  5    4    2            |
|  ↑   ↑   ↑           |
|  0    1    3            |
 --------------------------
  大                  小
```
你可以看到，对于上面的这些过程，每次在元素进来之前，我们都可以通过`Deque.peekFirst()`操作来获取队列的头部，也就是整个队列的最大值，同时也是当前窗口的最大值。

每进入一个元素我就可以取最大值，每进入一个元素我就可以取最大值，每进入一个元素我就可以取最大值。

因此，我就是通过这种既能从头部进出，又能从尾部进出的结构，来维持窗口的最大值的。

好了，现在还剩下索引为4的元素6想要进入队列，我们发现6比队列中任何一个元素都要大，所以我们将队列中的所有元素都弹出，然后只让6进入，如下所示：

```
头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  4                      |
 --------------------------
  大                  小
```
此时，窗口中的最大值就是6了。要注意一点的是：如果此时又来了一个索引为5的元素6想要进入队列中，则我们需要将之前的索引为4的元素6进行弹出，让新来的6进入，此时就变成了如下所示：

```
头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  5                      |
 --------------------------
  大                  小
```
为什么在元素相等的情况下，也要更新元素呢？

这是因为窗口是每次向右进行滑动的，每次进入到窗口中的值都有可能是当前窗口中最大的值，我们将相同的值进行更换，其实是为了更新它的索引。这样在窗口进行滑动的时候，每次的最大值都是新的，就能保持最大。

删除元素
不妨假设以下场景，窗口大小是 2，之前窗口中包含5和4，但是此时已经来到了4、1元素，队列中的情况也如下所示：

```
元素： 5  [4  1]  2
索引： 0   1  2   3

头部                    尾部
 --------------------------
|  5   4   1              |
|  ↑  ↑  ↑             |
|  0   1   2              |
 --------------------------
  大                  小
```
由于元素5已经被滑动窗口略过了，所以我们应将队列中的最大值，也就是5弹出，让4成为当前窗口新的最大值，如下所示：

```
头部                    尾部
 --------------------------
|     4   1               |
|     ↑  ↑              |
|     1   2               |
 --------------------------
  大                  小
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums==null||nums.length==0||k==0||nums.length<k){
            return new int[0];
        }
        int len=nums.length;
        int[] ans=new int[len-k+1];
        int idx=0;
        Deque<Integer> deque=new LinkedList<>();
        for(int i=0;i<len;i++){
            while(!deque.isEmpty()&&nums[deque.peekLast()]<=nums[i]){
                deque.pollLast();
            }
            deque.offerLast(i);
            //由于单调队列中的元素即数组下标必然单调递增，因此如果要排除的元素在deque中，则必然是在队头
            if(deque.peekFirst()==i-k){
                    deque.pollFirst();
            }
            if(i>=k-1){
                ans[idx++]=nums[deque.peekFirst()];
            }
        }
        return ans;
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(N)$，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。
- 空间复杂度：$O(N)$，输出数组使用了 $O(N−k+1)$ 空间，双向队列使用了 $O(k)$。
### 解法二
暴力：
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums==null||nums.length==0||k==0){
            return new int[0];
        }
        int len=nums.length;
        int[] ans=new int[len-k+1];
        int idx=0;
        for(int i=0;i<=len-k;i++){
            int maxNum=nums[i];
            for(int j=1;j<k;j++){
                maxNum=maxNum>nums[i+j]?maxNum:nums[i+j];
            }
            ans[idx++]=maxNum;
        }
        return ans;
    }
}
```
### 解法三
优先队列，超时
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 建立最大堆
        PriorityQueue<Integer> max = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer i1, Integer i2) {
                return i2 - i1;
            }
        });
        int n = nums.length;
        if (n == 0) {
            return nums;
        }
        int result[] = new int[n - k + 1];
        int index = 0;
        for (int i = 0; i < n; i++) {
            //移除第一个元素
            if (max.size() >= k) {
                max.remove(nums[i - k]);
            }
            max.offer(nums[i]);
            //更新 result
            if (i >= k - 1) {
                result[index++] = max.peek();
            }
        }
        return result;
    }
}
```